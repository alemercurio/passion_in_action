
#include <cstdio>
#include "miosix.h"

using namespace std;
using namespace miosix;

// Usual labels for GPIOs:
// SCK  -> SPI clock for slave devices (generated by the microcontroller)
// MISO -> Master Input Slave Output data line (slave to master data)
// MOSI -> Master Output Slave Input data line (master to slave data)
// CS   -> slave Chip Select (used by microcontroller to select the slave device)

typedef Gpio<GPIOA_BASE,5> sck;
typedef Gpio<GPIOA_BASE,6> miso;
typedef Gpio<GPIOA_BASE,7> mosi;
typedef Gpio<GPIOE_BASE,3> cs;

void spiConfig()
{
    // CS has to be configured as output and put to high state. This because the
    // chip select, by design, is active low: when the master wants to communicate
    // with a slave, it has to pull the corresponding CS line to low
    cs::mode(Mode::OUTPUT);
    cs::high();

    // SCK, MISO and MOSI GPIOs have to be configured in alternate mode. In this
    // mode they are controlled by the internal SPI peripheral and not by the 
    // GPIO control registers
    sck::mode(Mode::ALTERNATE);
    miso::mode(Mode::ALTERNATE);
    mosi::mode(Mode::ALTERNATE);

    // STM32F4 chips have many peripherals connected to the same pins. The selection
    // of which peripheral is connected to the GPIO pins is done through this
    // function.
    // To have a list of all the peripherals and their corresponding alternate
    // function number, see device's datasheet in the section "Alternate function
    // mapping"
    sck::alternateFunction(5);
    miso::alternateFunction(5);
    mosi::alternateFunction(5);

    // Now enable the SPI peripheral by setting to 1 the corresponding bit into
    // the clock gating register. This gives clock to peripheral's hardware
    // allowing to read and write hardware. This operation must be done before
    // accessing any of the peripheral's registers, otherwise reading and/or
    // writing to them will have no effect.
    {
        FastInterruptDisableLock dLock;
        RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;
        RCC_SYNC();
    }

    // Once clock has been enabled, configure the SPI peripheral writing to its
    // registers.
    // For detailed informations, see the reference manual for the STM32F407xx
    // family at page 857 and following

    SPI1->CR1 = SPI_CR1_SSM     // Software slave management enabled, CS line
                                // is controlled by software and not by the peripheral

              | SPI_CR1_SSI     // Internal slave select, see above

              | SPI_CR1_MSTR    // Peripheral is an SPI master

              | SPI_CR1_BR_2    // Division factor for SPI clock generation.
                                // SPI1 is connected to APB2 bus, which is clocked
                                // at 84MHz. Setting to 1 the third bit of division
                                // factor we obtain an SCK frequency of 84MHz / 32 = 2.625MHz

              | SPI_CR1_SPE;    // Finally enable the peripheral
}

unsigned char spiSendRecv(unsigned char data)
{
    // Put data we want to send into peripheral's data register
    SPI1->DR = data;

    // Wait until the RX Not Empty flag in peripheral's status register is set.
    // This signals that the data transfer is completed and the data received
    // from the slave device is into data register
    while((SPI1->SR & SPI_SR_RXNE) == 0)
    {

    }

    // Read received data and return it exiting from this function
    return SPI1->DR;
}

int main()
{
    spiConfig();    // Configure the SPI peripheral

    // Once the SPI peripheral is configured, we can configure the accelerometer
    // writing in its configuration registers.
    // We will act on CTRL_REG1 located at address 20h
    // Registers' description can be found on device's datasheet starting from
    // page 16

    uint8_t flags = (1 << 6)    // Set 6th bit to put device in active mode

                  | (1 << 5)    // Set 5th bit to set +/- 8g as full scale value

                  | (1 << 2)    // Set 3rd bit to enable measurement on Z axis

                  | (1 << 1)    // Set 2nd bit to enable measurement on Y axis

                  | (1 << 0);   // Set 1st bit to enable measurement on X axis

    // Finally, send data to the accelerometer.
    // Pull down CS line to activate the SPI slave (the accelerometer)
    cs::low();

    // Firstly send the address of the register we want to write
    spiSendRecv(0x20);

    // And then its new value
    spiSendRecv(flags);

    // Lastly, bring CS line back to high state to signal that the communication
    // is finished
    cs::high();

    usleep(10);     // Datasheet says that CS line must stay high for at least 10us

    while(1)
    {
        // We can now read the acceleration measured on the three axes by reading
        // the corresponding registers into the chip.
        //
        // The procedure is the following:
        //
        // - send the register address with the 8th bit set to 1 in order to signal
        //   that we want to read the register. This is easily done through a 
        //   bitwise or operation between 0x80 and the register address.
        //
        // - Send a dummy value to the chip to make it write back the register
        //   content. Remember that SPI is a syncronous bus: while the master is
        //   writing to MOSI, the slave is writing to MISO

        signed char xAcc = 0;  // Acceleration has sign
        signed char yAcc = 0;
        signed char zAcc = 0;

        // Read X axis acceleration, whose register is at address 0x29
        cs::low();
        spiSendRecv(0x80 | 0x29);   // Send register address with read flag set
        xAcc = spiSendRecv(0x00);   // Send dummy value to read back the data
        cs::high();
        usleep(10);

        // Read Y axis acceleration, whose register is at address 0x29
        cs::low();
        spiSendRecv(0x80 | 0x2B);
        yAcc = spiSendRecv(0x00);
        cs::high();
        usleep(10);

        // Read Z axis acceleration, whose register is at address 0x29
        cs::low();
        spiSendRecv(0x80 | 0x2D);
        zAcc = spiSendRecv(0x00);
        cs::high();
        usleep(10);

        // Convert values returned by the sensor into an acceleration expressed
        // in m/s
        // Value returned are 8 bit plus sign, so their range is Â±128. Since the
        // full scale value is 8g we have to multiply by 8 * 9.81 and divide by
        // 128
        float x = (static_cast<float>(xAcc) * 8 * 9.81)/128;
        float y = (static_cast<float>(yAcc) * 8 * 9.81)/128;
        float z = (static_cast<float>(zAcc) * 8 * 9.81)/128;

        printf("Acceleration x: %.2f, y: %.2f, z: %.2f\n", x, y, z);

        // Wait for 100ms
        Thread::sleep(100);
    }

    return 0;
}